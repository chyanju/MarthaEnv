import re
import json
import pickle
import gym
import igraph
import os
import time

import numpy as np

from typing import List, Tuple, Any, Union, Dict
from gym.utils import seeding

from .gui_element import GuiElement
from .apk import Apk
from .logcat_watcher import LogcatWatcher

# from screen import ScreenObject
# from saveScreen import ScreenData

class ApkEnvironment(gym.Env):
    SCREEN_MAX_ACTIONS = 20

    def __init__(self, config, dummy=False):
        self.config = config
        self.max_step = config["max_step"]

        # =========== #
        # apk related #
        # =========== #

        self.apk_prefix = "{}/{}".format(config["apk_folder"], config["apk_name"])
        self.apk = None
        self.apk_call_graph = None
        self.apk_onclicks = None
        self.apk_logcat_watcher = None

        # ====================== #
        # neural network related #
        # ====================== #

        self.special_token_list = ["<PAD>"]
        self.base_token_list = self.special_token_list
        self.token_list = self.base_token_list + list(range(ApkEnvironment.SCREEN_MAX_ACTIONS))
        self.token_dict = {self.token_list[i]:i for i in range(len(self.token_list))}

        self.curr_action_seq = None
        if not dummy:
            _ = self.reset()

        # inherited variables
        self.action_space = gym.spaces.Discrete(ApkEnvironment.SCREEN_MAX_ACTIONS)
        self.observation_space = gym.spaces.Dict({
            "start": gym.spaces.Box(0,1,shape=(1,),dtype=np.int32),
            "action_mask": gym.spaces.Box(0, 1, shape=(ApkEnvironment.SCREEN_MAX_ACTIONS,), dtype=np.int32),
            "nn_seq": gym.spaces.Box(0, len(self.token_list)+1000, shape=(self.max_step, ), dtype=np.int32),
        })

    def action_seq_to_nn_seq(self, arg_action_seq):
        # go see the comments in the SolInv project
        # reserve 0 for padding
        return [p+len(self.base_token_list) for p in arg_action_seq]

    def pad_to_length(self, arg_obj, arg_length):
        return arg_obj + [self.token_dict["<PAD>"] for _ in range(arg_length-len(arg_obj))]

    def get_curr_state(self):
        # fixme: currently only use the action sequence to be the state, need to update
        return self.pad_to_length(self.action_seq_to_nn_seq(self.curr_action_seq), self.max_step)

    def setup(self, arg_apk_prefix):
        self.apk = Apk(apk_path="{}_instrumented.apk".format(arg_apk_prefix))
        # graph.p is generated by a preprocessing step by 'python callgraph.py APK'
        self.apk_call_graph = igraph.Graph.Read_Pickle("{}_graph.p".format(arg_apk_prefix))
        # this file should be generated by 'python layout.py APK'
        self.apk_onclicks = None
        with open("{}_onclicks.p".format(arg_apk_prefix), "rb") as f:
            self.apk_onclicks = pickle.load(f)
        self.apk_logcat_watcher = LogcatWatcher(self.apk, self.apk_onclicks)

    def reset(self):
        self.setup(self.apk_prefix)
        self.apk.clear_logcat()
        self.apk.launch_app()
        time.sleep(2)
        self.curr_action_seq = []
        tmp_action_list = self.apk.get_curr_actions()
        return {
            "start": [1],
            # edge use of pad_to_length
            "action_mask": self.pad_to_length([1 for _ in range(len(tmp_action_list))], ApkEnvironment.SCREEN_MAX_ACTIONS),
            "nn_seq": self.pad_to_length(self.action_seq_to_nn_seq(self.curr_action_seq), self.max_step),
        }

    def is_done(self):
        tmp_action_list = self.apk.get_curr_actions()
        return len(tmp_action_list) <= 0

    def step(self, arg_action_id: int):
        tmp_action_list = self.apk.get_curr_actions()
        if arg_action_id >= len(tmp_action_list):
            raise EnvironmentError("Action id is not in range, required: [0, {}), got: {}".format(len(tmp_action_list), arg_action_id))

        if self.is_done():
            raise EnvironmentError("There is available action; the environment status is done.")

        self.apk.perform_action(tmp_action_list[arg_action_id])
        self.curr_action_seq = self.curr_action_seq + [arg_action_id]

        tmp_reward = 1.0
        tmp_terminate = self.is_done()

        tmp_action_list = self.apk.get_curr_actions()
        return [
            {
                "start": [1],
                "action_mask": self.pad_to_length([1 for _ in range(len(tmp_action_list))], ApkEnvironment.SCREEN_MAX_ACTIONS),
                "nn_seq": self.pad_to_length(self.action_seq_to_nn_seq(self.curr_action_seq), self.max_step),
            },
            tmp_reward,
            tmp_terminate,
            {}, # info
        ]

    def seed(self, arg_seed: int=None):
        self.np_random, seed = seeding.np_random(seed)
        return [seed]

    def render(self, mode: str="human"):
        pass

    def close(self):
        pass

    def get_apk_call_graph(self) -> igraph.Graph:
        return self.apk_call_graph

    # this returns the corresponding vertex (node) id from the call graph given an action
    def get_node_for_action(self, arg_action: GuiElement):
        click_map = self.apk_logcat_watcher.get_click_map()
        if arg_action.resource_id in click_map:
            funct_name = click_map[arg_action.resource_id]
            try:
                return self.apk_call_graph.vs['name'].index(funct_name)
            except:
                raise Exception("Could not find function {} in call graph.".format(funct_name))
        else:
           raise Exception("Could not find resource id {} in click map.".format(arg_action.resource_id))

    # def get_abstract_whxml(self, arg_whxml: str, arg_nrow: int, arg_ncol: int, arg_nchannel: int) -> Any:
    #     screen = ScreenObject(arg_whxml, 1440, 2960)
    #     screen.setRelevantComponents(['clickable'])
    #     screen.fixedChannels =arg_nchannel
    #     screen.createFixedChannels()
    #     screen.setTileDimensions((arg_nrow, arg_ncol))
    #     return screen
        
       

