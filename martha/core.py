from typing import List, Any
import uiautomator
import sys
import traceback 
import subprocess
import re

LOCAL_STATE_NAME = "CURRENT_LOCAL_STATE"

class MState():
	"""
	This stores states from both the static analyzer and andorid emulator.
	"""
	def __init__(self, name : str, label : str) -> None:
		self._name = name
		self._label = label
		self._xml = ''

	def to_string(self):
		return "Name: "+self._name+" Label: "+self._label
	'''
	for now, just node name and label (might not be necessary but keep just in case)
	'''

class MEdge():
	'''
	A edge between 2 MStates- holds 2 states and the event that triggers the transition
	'''
	def __init__(self, source:MState, dest:MState, event:str, widget:str) -> None:
		'''
		2 node objects - in and out
		widget and event (can be compared to an MAction obj- need to figure out how to compare widget info to UIObj)
		'''
		self._source = source
		self._dest = dest
		self._event = event
		self._widget = widget
	
	def to_string(self):
		return "Source: "+self._source._name+" Dest: "+self._dest._name+" Evt: "+self._event+" Widget: "+self._widget

class MGraph():
	'''
	Represents the global window transition graph of the app
	Basically a python wrapper of the WTG object generated by GATOR
	'''
	'''
		list (dictionary?) of nodes
		list of edges
	'''
	def __init__(self, node_dict, edge_list)->None:
		self._node_dict = node_dict
		self._edge_list = edge_list
		self._init_node = node_dict['n1']	#TODO- make sure that this is assigned to the actual init node, not just the launcher
		# --> find the LAUNCHER NODE and the corresponding implicit_launch_event transition- the destination of that edge is the starting node

		#find the initial state by finding the LAUNCHER NODE first
		launcher_node : MState = None
		for node in node_dict.values():
			if "LAUNCHER_NODE" in node._label:
				launcher_node = node
				break
		print("launcher node: ", launcher_node.to_string())

		for edge in edge_list:
			if edge._source == launcher_node:
				self._init_node = edge._dest
		print("init state: ", self._init_node.to_string())
		
		self._current_node = self._init_node	#to track current location in graph as actions are taken to traverse it

class MAction():
	"""
	This stores actions for both the static analyzer and android emulator.
	"""
	def __init__(self, subject: uiautomator.AutomatorDeviceObject, action) -> None:
		'''
			subject: the object found by uiautomator that the action will be called from
			action: a lambda function that calls a specific action from the provided uiobject
		'''
		self._subject = subject
		self._action = action

class MAnalyzer():
	"""
	This is a wrapper for external static analyzer. 
	"""
	def __init__(self, binary_path, target_apk) -> None:
		self._binary_path = binary_path
		self._target_apk = target_apk

	def analyze(self) -> MGraph:
		"""
		This invokes the external analyzer to perform static analysis.
		Returns (bool): whether the operation is successful or not.
		"""
		# call the GATOR executable and dump the WTG of the provided APK to the file 'wtg.dot'
		# then deconstruct the WTG in that file to construct the global graph of the app as an MGraph object
		# for now, just parsing names and labels, not using stack info in wtg
		analyze_command = './'+self._binary_path+' a -p '+self._target_apk+ ' -client WTGDumpClient'
		
		try:
			call_result = subprocess.check_output(analyze_command, shell=True)
			print("Analysis successfully completed!")
		except subprocess.CalledProcessError as exec_err:
			print("Analyzer failed with the following err code: ", exec_err.returncode, exec_err.output)
			return None

		#open graph.txt to parse into MGraph
		graph_name = 'wtg.dot'
		constructed_graph : MGraph = None
		node_dict = {}
		edge_list = []

		with open(graph_name, 'r') as graph_file:
			for line in graph_file:
				if "label" in line:
					if "->" in line:
						edge_re = '(.+?)->+(.+?) \[label=".*evt: (.*?)\\\\nwidget: (.*?)\\\\nhandler.*"\];'
						edge_params = re.split(edge_re, line)
						edge_params = [x for x in edge_params if (x and not x.isspace())]
						if edge_params:
							source_node = edge_params[0].strip()
							dest_node = edge_params[1].strip()
							edge_event = edge_params[2].strip()
							edge_widget = edge_params[3].strip()
							edge_list.append(MEdge(node_dict[source_node], node_dict[dest_node], edge_event, edge_widget))

					else:
						node_re = '(.*) \[label="(.*)"\];'
						node_params = re.split(node_re, line)
						node_params = [x for x in node_params if (x and not x.isspace())]
						if node_params:
							curr_node = MState(node_params[0].strip(), node_params[1].strip())
							node_dict[node_params[0].strip()] = curr_node

		print("NODES")
		for x in node_dict.keys():
			print(x," : ", node_dict[x].to_string())

		print("EDGES")
		for x in edge_list:
			print(x.to_string())

		if node_dict and edge_list:
			constructed_graph = MGraph(node_dict, edge_list)

		return constructed_graph


	def state_shortest_distance(self, s0: MState, s1: MState) -> float:
		"""
		This computes the shortest distance between two states.
		Returns (float): the distance.
		"""
		pass

class MEnvironment():
	"""
	Main interactive environment class; the environment is stateful.
	"""
	# def __init__(self, device: Any, analyzer: MAnalyzer) -> None:
	def __init__(self, device: Any, global_graph: MGraph) -> None:
		"""
		Arguments:
			device (Any): (FIXME) type should be Device, the device object provided by uiautomator
			analyzer (MAnalyzer): the analyzer
		"""
		self._device = device
		# self._analyzer = analyzer
		self._global_graph = global_graph

		#TODO- seems like the env should have a GRAPH member var, passed in after being generated by the analyzer, not an analyzer mem var
	
	def reset(self) -> bool:
		"""
		Reset the status of the current device/emulator;
		will also reset the alignment between analyzer and device/emulator
		Returns (bool): whether the operation is successful or not.
		"""
		pass

	def get_current_device_state(self) -> MState:
		"""
		Access the current state.
		Returns (MState): the current states of the device/emulator you are in.
		"""
		# call adb window dump to get current active xml
		# name- some placeholder (LOCAL CURRENT) - make a global const for now
		# label- package and current activity- from adb dumpsys
		# create and return new MState obj
		try:
			call_dump = subprocess.check_output("adb shell uiautomator dump", shell=True).decode('ascii')
			print("OUT: ", call_dump)
			
			#split output on / to call the location of the window dump
			call_dump = call_dump.strip().split('/')
			if len(call_dump) > 1:
				print("MOD: ", call_dump[1]+'/'+call_dump[2])
		except subprocess.CalledProcessError as err:
			print("ERR: ", err.returncode)
			try:
				call_dump = subprocess.check_output('adb kill-server; adb shell uiautomator dump', shell=True).decode('ascii')
				print("SEC OUT: ", call_dump)
				call_dump = call_dump.strip().split('/')
				if len(call_dump) > 1:
					print("MOD: ", call_dump[1]+'/'+call_dump[2])
				else: 
					#call did not properly return the dump location, so shouldn't attempt to access
					return None
			except subprocess.CalledProcessError as err:
				print("SEC ERR: ", err.returncode)
				print("RETURNING NONE")
				return None

		#if reach this point, then the call to dump was successful, and call_dump[1]+'/'+call_dump[2] holds the location to pull
		#pull the dump from emulator- will create local file with name contained in call_dump[2]
		pull_dump = subprocess.call('adb pull '+call_dump[1]+'/'+call_dump[2], shell=True)
		window_dump = open(call_dump[2])
		window_contents = window_dump.read()
		print("CONTENT: ", window_contents)

		#now get current activity from adb dumpsys window, to use as mstate label
		try:
			curr_activity = subprocess.check_output("adb shell dumpsys window windows | grep -E 'mCurrentFocus' | cut -d '/' -f2 | cut -d '}' -f1", shell=True)
			curr_activity = curr_activity.decode('ascii')
			print("RESULT: ", curr_activity)
			curr_state = MState(LOCAL_STATE_NAME,curr_activity)
			curr_state._xml = window_contents
			print("about to return curr state!!")
			return curr_state
		except subprocess.CalledProcessError as err:
			print("ERR in getting activity: ", err.returncode)
			return None

		return None
		# if not get_dump:
		# 	# if the dump fails, try restarting the server and dumping again
		# 	# if it fails again, return a None object
		# 	get_dump = subprocess.call('adb kill-server; adb shell uiautomator dump', shell=True)
		# 	if not get_dump:
		# 		return None
		



	def get_current_analyzer_state(self) -> MState:
		"""
		Access the current state.
		Returns (MState): the current states of the analyzer you are in.
		"""
		pass

# TODO: right now, just returns list of 'click' actions with subjects- generalize to all possible actions on all active objects later!
	def get_available_actions(self) :#-> List[MAction]:
		"""
		Given the current internal status, return the user a list of available actions.
		Returns (List[MAction]): a list of available actions for the current state of emulator.
		"""
		first_try = self._device(classNameMatches="android.widget.*")

		action_list = []

		for i in first_try:
			if i.info['clickable']:
				action_list.append( MAction(i, lambda x : x.click()))

		print("trying to look w resourceid!")
		sec_try = self._device(resourceIdMatches="2131230725|REC")
		for x in first_try:
			print("in LOOP")
			print(x.info)

		# print("POST attempt")
		return action_list

	def take_action(self, action: MAction) -> bool:
		"""
		Execute the provided action on both the device/emulator and analyzer.
		Returns (bool): whether the action is executed successfully.
		"""
		try:
			print("ACTION SUBJECT: ", action._subject.info)
			action._action(action._subject)
			print("Action successful! :)")
			# look for edges that originate with current_node and are 'click' actions (for now)
			# can match the edge's widget var with the action subjects info[className]
			# but how to compare text/id??? gator/uiautomator don't really provide any corresponding info :(((
			# TODO- determine which edge is being taken, so that the global graph current state can be updated
			# for edge in self._global_graph._edge_list:

			return True
		except:
			print ("The action could not be executed :(")
			# print("STACK TRACE: ")
			# traceback.print_exc()
		return False

	def align(self) -> bool:
		"""
		Align the analyzer state to the current state of the device/emulator.
		Returns (bool): whether the operation is successful or not.
		"""
		pass


